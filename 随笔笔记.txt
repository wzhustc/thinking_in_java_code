1、方法重载为啥不能根据返回值重载？
答：首先重载可以根据参数的多少、类型和顺序来重载，但是不能根据返回值重载
原因在于：
(1)、有时候，我们关注的是使用这个方法，而不关注返回的是什么，所以返回值不能作为一个必须的选项
(2)、对于强制类型转换，我们可以将int型转为short，byte，int。然而我们并不知道这个重载是从哪个重载来的，会引起混乱。

2、构造方法
如果你没有重载构造方法，那编译程序会调用默认的构造方法；
如果你重载了构造方法，那在构建对象时，必须要使用你重载的构造方法中的一个(如果为多个的话),除非你手动的把默认的构造方法也写在程序里。

3、尽管可用this调用一个构建器，但不可调用两个。除此以外，构建器调用必须是我们做的第一件事情，否则会收到编
译程序的报错信息。

4、static
static 详见http://www.cnblogs.com/dolphin0520/p/3799052.html
静态能访问静态，非静态能访问静态， 静态不能访问非静态，非静态能访问非静态。

5、在这里有必要总结一下对象的创建过程。请考虑一个名为Dog的类：
(1) 类型为Dog的一个对象首次创建时，或者Dog类的static方法／static字段首次访问时，Java解释器必须找到Dog.class（在事先设好的类路径里搜索）。
(2) 找到Dog.class后（它会创建一个Class对象，这将在后面学到），它的所有static初始化模块都会运行。因此，static初始化仅发生一次——在Class对象首次载入的时候。
(3) 创建一个new Dog()时，Dog对象的构建进程首先会在内存堆（Heap）里为一个Dog对象分配足够多的存储空间。
(4) 这种存储空间会清为零，将Dog中的所有基本类型设为它们的默认值（零用于数字，以及boolean和char的等价设定）。
(5) 进行字段定义时发生的所有初始化都会执行。
(6) 执行构建器。正如第6章将要讲到的那样，这实际可能要求进行相当多的操作，特别是在涉及继承的时候。

6、重载的好处：
继承的一个好处是它支持“累积开发”，允许我们引入新的代码，同时不会为现有代码造成错误。这样可将新错误隔离到新代码里。通过从一个现成的、功能性的类继承，
同时增添成员新的数据成员及方法（并重新定义现有方法），我们可保持现有代码原封不动（另外有人也许仍在使用它），不会为其引入自己的编错误。一旦出现错误，
就知道它肯定是由于自己的新代码造成的。这样一来，与修改现有代码的主体相比，改正错误所需的时间和精力就可以少很多。

7、final
若修饰基本类型，表示该基本类型无法改变，是一个常数
若修饰的是一个引用，则该引用在声明时必须初始化到一个具体的对象，
而且永远不能将引用指向另一个对象，but坑在于这个对象本身可以修改，
好比狸猫换太子，我们外界都只知道他是太子的身份，但是至于他自己是真太子还是狸猫，我们不用管。

8、final方法编译：
采用final方法的第二个理由是程序执行的效率。将一个方法设成final后，编译器就可以把对那个方法的所有调用都置入“嵌入”调用里。
只要编译器发现一个final方法调用，就会（根据它自己的判断）忽略为执行方法调用机制而采取的常规代码插入方法（将自变量压入堆栈；
跳至方法代码并执行它；跳回来；清除堆栈自变量；最后对返回值进行处理）。相反，它会用方法主体内实际代码的一个副本来替换方法调用。
这样做可避免方法调用时的系统开销。

9、綁定：
定义：将一个方法调用同一个方法主体连接在一起称为绑定，若在程序运行前执行绑定叫"早期绑定".绑定在运行期间进行，以对象的类型为基础，这个叫"后期绑定"
或者叫做"动态绑定"

10、重载和重写
重载发生在子类和父类之间，子类重载父类的方法，导致子类和父类有不同的表现，
重写指的是在同一个类中，由于参数顺序、参数个数和参数类型至少有一个不同，而导致的两个方法。

11、接口
"纯"抽象类，允许创建者规定一个类的基本形式：方法名、自变量列表以及返回类型但不规定方法主体，
接口也包含了基本数据类型的数据成员，但它们都默认为static和final

12、内部类的格式：先是封装类的名字，再跟随一个$，再跟随内部类的名字，如：WithInner$Inner.class，
如果内部类是匿名的，那么编译器会简单地生成数字，把它们作为内部类标识符使用


13、构造器的调用顺序：
（1）父类的构造方法肯定在一个子类的构造方法中被调用，而且逐渐向上链接，使得每个父类使用的构造方法都能得到调用。
（2）在租客U的构造方法中，如果我们没有明确指定对父类构造方法的调用，它会默默的调用默认构造方法。如果不存在默认构造方法，编译器报错

14、finalize() 方法
(1)垃圾收集器在认为某对象没有被引用的时候会调用finalize方法
(2)当一个对象一直可访问时，在整个生命周期里，这个方法可能都得不到调用
(3)垃圾收集器不能保证会在特定的时间内运行收集垃圾，所以finalize最好不要使用，除非你有特殊需要

------------------------------
插入的笔记：
15、java NIO笔记
(1) java NIO 主要几个类是：Channel、Buffer、Selector
Channel是通道的意思，类似于io中的流stream，但是比stream好的地方在于：Channel既可以读，也可以写，但是stream要不是读，要不是写，没有既可以读，也可以写
流是字节读和写，Channel是一块一块读，能质的提高读写的效率。
selector叫多路复用器

16、多路复用io
用户线程先注册socket，然后一个线程通过select方法通过轮询监听多个socket，一旦有socket能读，就读入

17、序列化
UID
静态变量的序列化，序列化是，不会保存静态变量的状态
父类在不实现序列化接口时，不参与序列化，值为null，如果实现序列化接口，就会参与序列化，并有值
trisient 表示字段不参与系列化操作
当一个对象被序列化后，再次序列化这个对象，发现这个对象并没有被序列化，只是在第二次时，对改对象加了一个5个长度字节的引用
序列化实现的是深克隆

18、正向代理代理的是客户端，反向代理代理的是服务器端 tomcat运行在jvm上，通过底层协议去监听端口  
下载nignx包 然后解压 解压完后 ./configure --prefix=/data/program/ngnix 然后编译 


ps -ef|grep nginx 查看运行的进程

虚拟主机的目的 就是将web服务器虚拟出多态主机
基于域名的虚拟主机    基于ip的虚拟主机

nignx配置：nignx.conf文件
nignx 里面可以根据不同主机名的配置 通过域名取到不同的网页
