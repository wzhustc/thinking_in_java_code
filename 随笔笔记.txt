1、方法重载为啥不能根据返回值重载？
答：首先重载可以根据参数的多少、类型和顺序来重载，但是不能根据返回值重载
原因在于：
(1)、有时候，我们关注的是使用这个方法，而不关注返回的是什么，所以返回值不能作为一个必须的选项
(2)、对于强制类型转换，我们可以将int型转为short，byte，int。然而我们并不知道这个重载是从哪个重载来的，会引起混乱。

2、构造方法
如果你没有重载构造方法，那编译程序会调用默认的构造方法；
如果你重载了构造方法，那在构建对象时，必须要使用你重载的构造方法中的一个(如果为多个的话),除非你手动的把默认的构造方法也写在程序里。

3、尽管可用this调用一个构建器，但不可调用两个。除此以外，构建器调用必须是我们做的第一件事情，否则会收到编
译程序的报错信息。

4、static
static 详见http://www.cnblogs.com/dolphin0520/p/3799052.html
静态能访问静态，非静态能访问静态， 静态不能访问非静态，非静态能访问非静态。

5、在这里有必要总结一下对象的创建过程。请考虑一个名为Dog的类：
(1) 类型为Dog的一个对象首次创建时，或者Dog类的static方法／static字段首次访问时，Java解释器必须找到Dog.class（在事先设好的类路径里搜索）。
(2) 找到Dog.class后（它会创建一个Class对象，这将在后面学到），它的所有static初始化模块都会运行。因此，static初始化仅发生一次——在Class对象首次载入的时候。
(3) 创建一个new Dog()时，Dog对象的构建进程首先会在内存堆（Heap）里为一个Dog对象分配足够多的存储空间。
(4) 这种存储空间会清为零，将Dog中的所有基本类型设为它们的默认值（零用于数字，以及boolean和char的等价设定）。
(5) 进行字段定义时发生的所有初始化都会执行。
(6) 执行构建器。正如第6章将要讲到的那样，这实际可能要求进行相当多的操作，特别是在涉及继承的时候。

6、重载的好处：
继承的一个好处是它支持“累积开发”，允许我们引入新的代码，同时不会为现有代码造成错误。这样可将新错误隔离到新代码里。通过从一个现成的、功能性的类继承，
同时增添成员新的数据成员及方法（并重新定义现有方法），我们可保持现有代码原封不动（另外有人也许仍在使用它），不会为其引入自己的编错误。一旦出现错误，
就知道它肯定是由于自己的新代码造成的。这样一来，与修改现有代码的主体相比，改正错误所需的时间和精力就可以少很多。

7、final
若修饰基本类型，表示该基本类型无法改变，是一个常数
若修饰的是一个引用，则该引用在声明时必须初始化到一个具体的对象，
而且永远不能将引用指向另一个对象，but坑在于这个对象本身可以修改，
好比狸猫换太子，我们外界都只知道他是太子的身份，但是至于他自己是真太子还是狸猫，我们不用管。

8、final方法编译：
采用final方法的第二个理由是程序执行的效率。将一个方法设成final后，编译器就可以把对那个方法的所有调用都置入“嵌入”调用里。
只要编译器发现一个final方法调用，就会（根据它自己的判断）忽略为执行方法调用机制而采取的常规代码插入方法（将自变量压入堆栈；
跳至方法代码并执行它；跳回来；清除堆栈自变量；最后对返回值进行处理）。相反，它会用方法主体内实际代码的一个副本来替换方法调用。
这样做可避免方法调用时的系统开销。









